defmodule <%= @module %>.Service do
  <%= unless @module_doc? do %>
  @moduledoc false
  <% end %>
  use GRPC.Service, name: <%= inspect(@service_name) %>, protoc_gen_elixir_version: "<%= @version %>"

  <%= if @descriptor_fun_body do %>
  def descriptor do
    # credo:disable-for-next-line
    <%= @descriptor_fun_body %>
  end
  <% end %>

  <%= for {method_name, input, output, _} <- @methods do %>
  rpc :<%= method_name %>, <%= input %>, <%= output %>
  <% end %>
end

defmodule <%= @module %>.Stub do
  <%= unless @module_doc? do %>
  @moduledoc false
  <% end %>
  use GRPC.Stub, service: <%= @module %>.Service

  @type option :: {:timeout, integer() | :infinity},
                  {:deadline, integer() | :infinity},
                  {:metadata, map()} |
                  {:return_headers, boolean()}
  
  @type unary_response(t) :: {:ok, t} | {:ok, map()} | {:error, GRPC.RPCError.t()}
  @type client_streaming_response() :: GRPC.Client.Stream.t()
  @type server_streaming_response(t) :: {:ok, Enumerable.t(t)} | {:ok, Enumerable.t(t), map()} | {:error, GRPC.RPCError.t()}

  <%= for {method_name, input, _output, args} <- @methods do %>
  <%= case args do %>
  <% %{client_streaming: true} -> %>
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t()) :: client_streaming_response()
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t(), [option]) :: client_streaming_response()

  <% %{server_streaming: true} -> %>
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t()) :: server_streaming_response(<%= Protobuf.Protoc.Generator.Util.type_from_type_name(@ctx, args.output_type) %>.t())
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t(), [option]) :: server_streaming_response(<%= Protobuf.Protoc.Generator.Util.type_from_type_name(@ctx, args.output_type) %>.t())
  <% _ -> %>
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t()) :: unary_response(<%= Protobuf.Protoc.Generator.Util.type_from_type_name(@ctx, args.output_type) %>.t())
  @callback <%= Macro.underscore(to_string(method_name)) %>(GRPC.Channel.t(), <%= input %>.t(), [option]) :: unary_response(<%= Protobuf.Protoc.Generator.Util.type_from_type_name(@ctx, args.output_type) %>.t())
  <% end %>
  <% end %>
end
